#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"name":"csharp"},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"html","languageName":"HTML"},{"name":"http","languageName":"HTTP"},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"mermaid","languageName":"Mermaid"},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"value"}]}}

#!markdown

# Microsoft Agent Framework - The Starter Guide

`Created by Arafat Tehsin`

Microsoft Agent Framework is an open-source .NET library in the Microsoft.Extensions.AI family for building reliable AI agents and multi-agent workflows. It provides clear primitives for composing agents, calling tools, managing memory, and persisting conversations.

It builds on lessons from Microsoft Semantic Kernel and AutoGen, providing a forward-looking, unified path for agentic development at Microsoft. Many patterns here will feel familiar if you've used those projects, with a cleaner surface area and multi-agent orchestration built-in.

What this notebook covers:

- Basics: single-agent chat and stateful threads.
- Tools: function tools and human-in-the-loop approvals.
- Structured output, persistence, and multimodal (images).
- Agent-as-Function composition and custom memory with multi-user personalization.

Learn more: https://github.com/microsoft/agent-framework

This notebook uses nightly packages and Azure OpenAI for the chat backend:

- Azure auth defaults to `AzureCliCredential` — run `az login` beforehand.
- Provide your Azure OpenAI endpoint in the `AOI_ENDPOINT_SWDN` environment variable.
- Optionally set `AOI_KEY_SWDN` if you prefer API key auth.

#!csharp

string azureOpenAIKey = Environment.GetEnvironmentVariable("AOI_KEY_SWDN");
string azureOpenAIEndpoint = Environment.GetEnvironmentVariable("AOI_ENDPOINT_SWDN");

#!markdown

### Configure environment variables

We read configuration from environment variables to avoid hardcoding secrets in the notebook and to support safe rotation in shared environments.

- `AOI_ENDPOINT_SWDN`: Your Azure OpenAI endpoint (e.g., https://<resource>.openai.azure.com)
- `AOI_KEY_SWDN` (optional with CLI auth): Azure OpenAI API key if you prefer key-based auth over `AzureCliCredential`.

Business value: Keeps credentials out of source control, enables CI/CD-friendly configuration.
Concept: Environment-based configuration and secret hygiene.

#!markdown

## Setup: packages and chat client

About the code that follows:

- `AzureOpenAIClient` is created with your endpoint and `AzureCliCredential`.
- The deployment/model name used is `gpt-4o`. Change it to match your Azure OpenAI deployment.
- If you want to use an API key instead of CLI auth, replace the credential with `new AzureKeyCredential(azureOpenAIKey)` when constructing the client.

Tip: If packages fail to restore, ensure you're on the latest .NET SDK and have network access to the feeds referenced by the nightly packages in the Agent Framework repo.

#!csharp

#r "nuget: Microsoft.Agents.AI, 1.0.0-preview.251009.1"
#r "nuget: Microsoft.Agents.AI.OpenAI, 1.0.0-preview.251009.1"
#r "nuget: Azure.Identity, *-*"
#r "nuget: Azure.AI.OpenAI, *-*"
#r "nuget: OpenAI, *-*"

using Azure.AI.OpenAI;
using Azure.Identity;
using Microsoft.Agents.AI;
using OpenAI;

var openAiClient = new AzureOpenAIClient(
    new Uri(azureOpenAIEndpoint),
    new AzureCliCredential());

var chatClient = openAiClient.GetChatClient("gpt-4o");

#!markdown

### Create a simple agent - Social Media Post Generator

In this agent, we're using a `ChatClient` to create an Agent with the relevant instructions and name. Then this agent is provided an input and invoked through `RunAsync` method.

#!csharp

AIAgent agent = chatClient.CreateAIAgent(
    "An AI agent that helps you write professional social media posts.",
    "GhostWriter");

string userInput = "I need to write a LinkedIn post about the benefits of customer feedback.";

// Invoke the agent and output the text result.
Console.WriteLine(await agent.RunAsync(userInput));

// // Invoke the agent with streaming support.
// await foreach (var update in agent.RunStreamingAsync(userInput))
// {
//     Console.WriteLine(update);
// }

#!markdown

### Introducing threads for stateful conversations

Here, we reuse the same thread to keep context between messages. After asking for Sydney’s weather, the follow-up "What about tomorrow?" works because the thread stores prior turns.

It reduces user repetition and improves multi-turn completion rates. `AgentThread` retains conversation state; pass the same thread to `RunAsync`.

#!csharp

using Microsoft.Agents.AI;
using Azure.AI.OpenAI;
using Azure.Identity;
using OpenAI;

AIAgent agent = chatClient.CreateAIAgent(
    "You are an agent designed to query and retrieve information about the weather of a given location. If you have been asked to provide information about two distinguish locations then you need to get the information appropriately. For now, just make it up, you do not have to call any service.",
    "WeatherAgent");

string userInput = "What is the weather in Sydney?";

// Invoke the agent and output the text result.
AgentThread thread = agent.GetNewThread();
Console.WriteLine(await agent.RunAsync(userInput, thread));

string newUserInput = "What about tomorrow?";
Console.WriteLine(await agent.RunAsync(newUserInput, thread));

#!markdown

### Create a function tool - Flight Tracker

This cell defines a simple tool as a static C# method with `Description` attributes for parameters and return values. We’ll later expose it to an agent using `AIFunctionFactory.Create(...)` so the agent can call it when the user asks about flights.

#!csharp

using System;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Net.Http;
using System.ComponentModel;

public class FlightTracker
{
    private static string flightAPIKey = Environment.GetEnvironmentVariable("AVIATIONSTACK_KEY");
    private static readonly HttpClient client = new HttpClient();

[Description("Tracks the flight status of a provided source and destination")]
[return: Description("Flight details and status")]
public static async Task<string> TrackFlightAsync(
[Description("IATA code for the source location")] string source,
[Description("IATA code for the destination location")] string destination,
[Description("IATA code for the flight")] string flightNumber,
[Description("Count of flights")] int limit)
{
    string url = $"http://api.aviationstack.com/v1/flights?access_key={flightAPIKey}&dep_iata={source}&arr_iata={destination}&limit={limit}&flight_iata={flightNumber}";

    var response = await client.GetAsync(url);
    response.EnsureSuccessStatusCode();
    string responseBody = await response.Content.ReadAsStringAsync();

  
  return responseBody;
}

}

#!markdown

### Use the tool in an agent - Flight Tracker Agent

Here we wire the `FlightTracker.TrackFlightAsync` function into an agent via `AIFunctionFactory.Create(...)`. The agent interprets the user’s intent (flight status) and invokes the tool with the right arguments. Streaming is optional and shown commented.

#!csharp

using Microsoft.Agents.AI;
using Microsoft.Extensions.AI;

AIAgent agent = chatClient.CreateAIAgent(
    "You are an agent responsible for tracking the flight statuses between source and the destination.",
    "FlightTrackerAgent",
    tools: [AIFunctionFactory.Create(FlightTracker.TrackFlightAsync)]);

string userInput = "Track the flight status of from Sydney to Melbourne.";
Console.WriteLine(await agent.RunAsync(userInput));

// Streaming agent interaction with function tools.
// await foreach (var update in agent.RunStreamingAsync(userInput))
// {
//     Console.WriteLine(update);
// }

#!markdown

### Human in the loop

This section introduces a lightweight BudgetAdvisor tool that determines whether a proposed itinerary is over or under a user's budget. We use it to demonstrate human-in-the-loop control: the agent must request your approval before invoking this tool.

This adds oversight for sensitive actions and builds user trust.

Human-in-the-loop approvals with a gated tool (BudgetAdvisor) prior to execution.

#!csharp

public class BudgetAdvisor
{
    [Description("Evaluate the total cost of the itinerary")]
    [return: Description("over or under budget")]
    public static async Task<string> EvaluateTotalCostAsync(
        [Description("Total user's budget")] int userBudget,
        [Description("Estimated budget")] int estimatedBudget
    )
    {
        // If an estimated budget is over the user's budget, return that it is over budget
        if (estimatedBudget > userBudget)
        {
            return "over budget";
        }
        else
        {
            return "under budget";

        }
    }
}

#!markdown

### Add approvals to tool calls

We wrap the budget-evaluation tool with an approval layer so sensitive operations require a user decision. The agent emits `FunctionApprovalRequest` items, and we handle them in a loop—asking the user to approve or deny, then resuming the agent with the response.

#!csharp

using System.Linq;

#pragma warning disable
// Step 1: Create the base AI function from the static method
var budgetFunction = AIFunctionFactory.Create(BudgetAdvisor.EvaluateTotalCostAsync);
// var flightFunction = AIFunctionFactory.Create(FlightTracker.TrackFlightAsync);

// Step 2: Wrap the AI function with an approval-required wrapper
var approvalFunction = new ApprovalRequiredAIFunction(budgetFunction);

// Step 3: Prepare the tools collection for the agent
var tools = new[] { approvalFunction };

// Step 4: Create the agent using the prepared tools
AIAgent agent = chatClient.CreateAIAgent(
    "You are an agent responsible for planning a trip itinerary within a specified budget. Your budget is 1500 AUD",
    "TripPlannerAgent",
    tools: tools);

string userInput = "Plan a trip to New Zealand including flights, accommodation, and activities including the total cost.";

AgentThread thread = agent.GetNewThread();
var response = await agent.RunAsync(userInput, thread);

var userInputRequests = response.UserInputRequests.ToList();

while (userInputRequests.Count > 0)
{
    // Ask the user to approve each function call request.
    // For simplicity, we are assuming here that only function approval requests are being made.
    var userInputResponses = new List<ChatMessage>();
    foreach (var functionApprovalRequest in userInputRequests.OfType<FunctionApprovalRequestContent>())
    {
        Console.WriteLine($"The agent would like to invoke the following function, please reply Y to approve: Name {functionApprovalRequest.FunctionCall.Name}");
        var input = await Microsoft.DotNet.Interactive.CSharp.CSharpKernel.GetInputAsync("Approve? (Y/N)");
        bool approved = input?.Equals("Y", StringComparison.OrdinalIgnoreCase) ?? false;
        userInputResponses.Add(new ChatMessage(ChatRole.User, [functionApprovalRequest.CreateResponse(approved)]));
    }

    //Console.WriteLine($"\n Pre-Agent: {response}");

    // Pass the user input responses back to the agent for further processing.
    response = await agent.RunAsync(userInputResponses, thread);
    userInputRequests = response.UserInputRequests.ToList();

    Console.WriteLine($"\nAgent: {response}");
    // For streaming use:
    // updates = await agent.RunStreamingAsync(userInputResponses, thread).ToListAsync();
    // userInputRequests = updates.SelectMany(x => x.UserInputRequests).ToList();
}

#!markdown

#### Define a schema for structured responses

We declare a simple `Appointment` POCO to shape the model’s response. This enables reliable parsing and downstream automation (calendar/ticket creation) without brittle text scraping.

Consistent data for integrations and audit. JSON schema-constrained output mapped to a typed model.

#!csharp

using System.Text.Json.Serialization;

public class Appointment
{
    [JsonPropertyName("date")]
    public string? Date { get; set; }

    [JsonPropertyName("time")]
    public string? Time { get; set; }

    [JsonPropertyName("location")]
    public string? Location { get; set; }

    [JsonPropertyName("furtherquestion")]
    public string? FurtherQuestion { get; set; }

    [JsonPropertyName("iscomplete")]
    public bool IsComplete { get; set; }
    
}

#!markdown

#### Guide the dialog and parse JSON

We set the response format to the appointment schema, loop until all fields are collected, and deserialize the JSON into our POCO. Only missing fields trigger follow-up questions.

Fewer back-and-forths and clean hand-off to systems.

`ChatResponseFormat.ForJsonSchema` + `Deserialize<T>()` with a prompt loop.

#!csharp

using System.Text.Json;

ChatClientAgentOptions agentOptions = new(name: "AppointmentAssistant", instructions: "You are an assistant that helps schedule appointments based on user preferences. Keep asking further questions until you have all the information needed to schedule the appointment.")
{
    ChatOptions = new()
    {
        ResponseFormat = ChatResponseFormat.ForJsonSchema(
            schema: AIJsonUtilities.CreateJsonSchema(typeof(Appointment)),
            schemaName: "AppointmentInfo",
            schemaDescription: "Information about an appointment including the date, time, and location")
    }
};

AIAgent agent = chatClient.CreateAIAgent(
    agentOptions);

AgentThread thread = agent.GetNewThread();
Appointment? appointment = null;
bool isContinue = true;

// First prompt - ask the user for appointment details
string? userInput = await Microsoft.DotNet.Interactive.CSharp.CSharpKernel.GetInputAsync("Please provide the appointment details?");

while (isContinue)
{
    // Send the user's input (or previous agent prompt reply) to the agent
    var response = await agent.RunAsync(userInput, thread);

    // Try to deserialize structured appointment info
    appointment = response.Deserialize<Appointment>(JsonSerializerOptions.Web);

    if (appointment != null && appointment.IsComplete)
    {
        isContinue = false;
        break;
    }
    else
    {
        userInput = await Microsoft.DotNet.Interactive.CSharp.CSharpKernel.GetInputAsync(appointment.FurtherQuestion);
    }
}

// Ensure appointment is not null before printing
appointment ??= new Appointment();

Console.WriteLine($"Appointment Details:\nDate: {appointment.Date}\nTime: {appointment.Time}\nLocation: {appointment.Location}");

#!markdown

#### Save conversation state

We serialize the `AgentThread` to a `JsonElement` and write it to storage (a temp file here). This lets users resume complex tasks later without repeating details.

This enables the continuity across sessions and devices. `AgentThread.Serialize()` to persist conversation context.

#!csharp

using System.IO;

AIAgent agent = chatClient.CreateAIAgent(
    "You are an assistant that helps schedule medical appointments based on user preferences. Keep asking further questions until you have all the information needed to schedule the appointment.",
    "MedicalAssistant");

// Start a new thread for the agent conversation.
AgentThread thread = agent.GetNewThread();

// Run the agent with a new thread.
Console.WriteLine(await agent.RunAsync("I am James, I usually book with Dr. Sandra, can you please find me a better slot with her on 19th November?", thread));

// Serialize the thread state to a JsonElement, so it can be stored for later use.
JsonElement serializedThread = thread.Serialize();

// Save the serialized thread to a temporary file (for demonstration purposes).
string tempFilePath = Path.GetTempFileName();
await File.WriteAllTextAsync(tempFilePath, JsonSerializer.Serialize(serializedThread));

Console.WriteLine($"Serialized thread saved to: {tempFilePath}");

#!markdown

#### Resume from storage

We load the serialized thread, deserialize it, and continue the conversation seamlessly—preserving context and prior decisions.

It reduces friction and higher task completion. `agent.DeserializeThread(...)` to restore state and proceed.

#!csharp

using System.Text.Json.Serialization;
using System.Text.Json;

// Load the serialized thread from the temporary file (for demonstration purposes).
JsonElement reloadedSerializedThread = JsonSerializer.Deserialize<JsonElement>(await File.ReadAllTextAsync(tempFilePath));

// Deserialize the thread state after loading from storage.
AgentThread resumedThread = agent.DeserializeThread(reloadedSerializedThread);

// Run the agent again with the resumed thread.
Console.WriteLine(await agent.RunAsync("No, I do not have it this time. I think afternoon would work better.", resumedThread));

#!markdown

#### Understand images alongside text

We send an image (as bytes) together with text and let the model reason over both. Great for signage, receipts, or simple visual checks.

Faster field decisions and fewer errors. Multimodal messages with `DataContent` (image) and `TextContent`.

#!csharp

AIAgent agent = chatClient.CreateAIAgent(
    "You are an agent that can analyse parking signs and advise if it is suitable for regular citizens to park or not. You need to provide a reason of your outcome.",
    "ParkingAgent");

var imagePath = Path.GetFullPath(@"resources\parking-sign.jpg");
byte[] imageBytes = await File.ReadAllBytesAsync(imagePath);
string base64 = Convert.ToBase64String(imageBytes);
var dataUri = $"data:image/jpeg;base64,{base64}";

// Create the message with the base64 image
ChatMessage message = new(ChatRole.User, [
    new TextContent($"Right now, it is {DateTime.Now} in Sydney. Can you please analyse this parking sign and let me know if I can park here?"),
    new DataContent(imageBytes, "image/jpeg")
]);

var thread = agent.GetNewThread();
Console.WriteLine(await agent.RunAsync(message, thread));

#!markdown

#### Compose agents into tools

We expose one agent (VisaAgent) as a callable function inside another (TravelPlanner). This ensures prerequisite checks happen before planning—without duplicating logic.

You can reuse expertise and reduce rework. `visaAgent.AsAIFunction()` to plug an agent into another agent’s toolset.

#!csharp

using Microsoft.Agents.AI;
using System.ComponentModel;

// Use Case: VisaAgent as a function tool inside a TravelPlanner agent
// 1) A function tool that answers simple visa eligibility rules (demo stub).
[Description("Check visa requirements for a nationality traveling to a destination.")]
static string CheckVisa(
    [Description("Traveler nationality (e.g., Australian).")] string nationality,
    [Description("Destination country (e.g., Japan).")] string destination)
{
    nationality = nationality?.ToLowerInvariant() ?? string.Empty;
    destination = destination?.ToLowerInvariant() ?? string.Empty;
    if (nationality.Contains("australian") && destination.Contains("new zealand"))
        return "Visa not required for short tourist stays.";
    return "Visa requirement depends on stay length and purpose; check official guidance.";
}

// 2) Create the VisaAgent with the function tool.
AIAgent visaAgent = chatClient.CreateAIAgent(
    instructions: "You are a visa advisor. Answer succinctly with a one-line decision and a short note.",
    name: "VisaAgent",
    description: "Provides basic visa guidance.",
    tools: [AIFunctionFactory.Create(CheckVisa)]);

// 3) Create the TravelPlanner and provide the VisaAgent as a function tool.
AIAgent travelPlanner = chatClient.CreateAIAgent(
    instructions: "You are a travel planner. First call the visa tool to check requirements, then propose a 3-day itinerary with brief bullets and indicative budget. Keep it under 150 words.",
    name: "TravelPlanner",
    description: "Plans short trips with prerequisite checks.",
    tools: [visaAgent.AsAIFunction()]);

// 4) Invoke the TravelPlanner which will call the VisaAgent tool internally.
Console.WriteLine(await travelPlanner.RunAsync("Plan a 3-day trip for an Australian traveler to New Zealand in October."));

#!markdown

#### Add personalised memory

We attach a custom `AIContextProvider` to capture dietary preferences and inject constraints before each call. Memory can be serialized and reused across threads.

It plans users actually follow, with fewer corrections. Implement `InvokedAsync`/`InvokingAsync`; persist via `Serialize`/`Deserialize`.

#!csharp

using System;
using System.Linq;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Agents.AI;

internal sealed class DietaryProfile
{
    [JsonPropertyName("dietType")]
    public string? DietType { get; set; }

    [JsonPropertyName("allergens")]
    public string[] Allergens { get; set; } = Array.Empty<string>();

    [JsonPropertyName("dislikes")]
    public string[] Dislikes { get; set; } = Array.Empty<string>();

    [JsonPropertyName("calorieTarget")]
    public int? CalorieTarget { get; set; }
}

internal sealed class DietaryMemory : AIContextProvider
{
    private readonly IChatClient _chatClient;

    public DietaryProfile Profile { get; set; }

    public DietaryMemory(IChatClient chatClient, DietaryProfile? profile = null)
    {
        _chatClient = chatClient;
        Profile = profile ?? new DietaryProfile();
    }

    public DietaryMemory(IChatClient chatClient, JsonElement serializedState, JsonSerializerOptions? jsonSerializerOptions = null)
    {
        _chatClient = chatClient;
        Profile = serializedState.ValueKind == JsonValueKind.Object
            ? serializedState.Deserialize<DietaryProfile>(jsonSerializerOptions)!
            : new DietaryProfile();
    }

    public override async ValueTask InvokedAsync(InvokedContext context, CancellationToken cancellationToken = default)
    {
        bool needsDietType = string.IsNullOrWhiteSpace(Profile.DietType);
        bool needsAllergens = Profile.Allergens == null || Profile.Allergens.Length == 0;
        bool needsDislikes = Profile.Dislikes == null || Profile.Dislikes.Length == 0;
        bool needsCalories = Profile.CalorieTarget == null;

        if ((needsDietType || needsAllergens || needsDislikes || needsCalories) && context.RequestMessages.Any(x => x.Role == ChatRole.User))
        {
            var result = await _chatClient.GetResponseAsync<DietaryProfile>(
                context.RequestMessages,
                new ChatOptions
                {
                    Instructions = "Extract the user's dietType (e.g., vegetarian, vegan, keto), allergens (array), dislikes (array), and calorieTarget (integer) if present. If not present, return nulls or empty arrays."
                },
                cancellationToken: cancellationToken);

            Profile.DietType ??= result.Result.DietType;
            Profile.Allergens = (Profile.Allergens == null || Profile.Allergens.Length == 0) && result.Result.Allergens != null 
                ? result.Result.Allergens 
                : Profile.Allergens;
            Profile.Dislikes = (Profile.Dislikes == null || Profile.Dislikes.Length == 0) && result.Result.Dislikes != null 
                ? result.Result.Dislikes 
                : Profile.Dislikes;
            Profile.CalorieTarget ??= result.Result.CalorieTarget;
        }
    }

    public override ValueTask<AIContext> InvokingAsync(InvokingContext context, CancellationToken cancellationToken = default)
    {
        StringBuilder instructions = new StringBuilder();

        if (string.IsNullOrWhiteSpace(Profile.DietType))
        {
            instructions.AppendLine("Ask the user for their diet type (e.g., vegetarian, vegan, keto) and wait for it before proceeding.");
        }
        else
        {
            instructions.AppendLine("Diet type: " + Profile.DietType + ".");
        }

        if (Profile.Allergens == null || Profile.Allergens.Length == 0)
        {
            instructions.AppendLine("Ask the user for any allergens (e.g., peanuts, shellfish) and wait for it if unknown.");
        }
        else
        {
            instructions.AppendLine("Never include allergens: " + string.Join(", ", Profile.Allergens) + ".");
        }

        if (Profile.Dislikes == null || Profile.Dislikes.Length == 0)
        {
            instructions.AppendLine("Ask the user for any disliked ingredients.");
        }
        else
        {
            instructions.AppendLine("Avoid disliked ingredients: " + string.Join(", ", Profile.Dislikes) + ".");
        }

        if (Profile.CalorieTarget == null)
        {
            instructions.AppendLine("Ask the user for a daily calorie target.");
        }
        else
        {
            instructions.AppendLine("Keep daily calories near: " + Profile.CalorieTarget + ".");
        }

        instructions.AppendLine("When planning meals, provide a 3-day dinner plan with brief bullets and a minimal grocery list.");

        return new ValueTask<AIContext>(new AIContext
        {
            Instructions = instructions.ToString()
        });
    }

    public override JsonElement Serialize(JsonSerializerOptions? jsonSerializerOptions = null)
    {
        return JsonSerializer.SerializeToElement(Profile, jsonSerializerOptions);
    }
}

// Create MealPlanner agent with memory factory.
AIAgent mealPlanner = chatClient.CreateAIAgent(new ChatClientAgentOptions
{
    Instructions = "You are a helpful meal planner. Ask for missing dietary details first, then produce a 3-day dinner plan with a short grocery list.",
    AIContextProviderFactory = ctx => new DietaryMemory(chatClient.AsIChatClient(), ctx.SerializedState, ctx.JsonSerializerOptions)
});

// Start a new thread (blank memory)
AgentThread mealThread = mealPlanner.GetNewThread();
Console.WriteLine(">> Meal Planner: Start conversation with blank memory\n");
Console.WriteLine(await mealPlanner.RunAsync("Hi, can you suggest dinners for the next 3 days?", mealThread));
Console.WriteLine(await mealPlanner.RunAsync("I am vegetarian and allergic to peanuts.", mealThread));
Console.WriteLine(await mealPlanner.RunAsync("I dislike mushrooms.", mealThread));
Console.WriteLine(await mealPlanner.RunAsync("Target about 1800 calories per day.", mealThread));

// Serialize memory and thread state
JsonElement savedMealThread = mealThread.Serialize();

Console.WriteLine("\n>> Resume with saved dietary profile\n");
AgentThread resumedMealThread = mealPlanner.DeserializeThread(savedMealThread);
Console.WriteLine(await mealPlanner.RunAsync("Now generate the 3-day dinner plan.", resumedMealThread));

// Read back memory
var resumedMemory = resumedMealThread.GetService<DietaryMemory>();
Console.WriteLine($"\nMEMORY - Diet: {resumedMemory?.Profile.DietType}");
Console.WriteLine($"MEMORY - Allergens: {string.Join(", ", resumedMemory?.Profile.Allergens ?? Array.Empty<string>())}");
Console.WriteLine($"MEMORY - Dislikes: {string.Join(", ", resumedMemory?.Profile.Dislikes ?? Array.Empty<string>())}");
Console.WriteLine($"MEMORY - CalorieTarget: {resumedMemory?.Profile.CalorieTarget}");

Console.WriteLine("\n>> New thread sharing existing dietary memory\n");
AgentThread newMealThread = mealPlanner.GetNewThread();
if (resumedMemory?.Profile is not null && newMealThread.GetService<DietaryMemory>() is DietaryMemory newThreadMemory)
{
    newThreadMemory.Profile = resumedMemory.Profile;
}
Console.WriteLine(await mealPlanner.RunAsync("Please regenerate with a Mediterranean style.", newMealThread));

#!markdown

### Multi-User Personalization

This section shows how to handle two different users in parallel by giving each their own `AgentThread` and `DietaryMemory`. The same `mealPlanner` agent generates plans tailored to each user's stored profile.

#!markdown

Run separate threads and memories per user so profiles and history don’t leak. Resume each user later by deserializing their saved thread.

It is trustworthy personalization at scale. One `AgentThread` + `AIContextProvider` per user for isolation.

#!csharp

// Two distinct users: Alice and Bob
var aliceProfile = new DietaryProfile
{
    DietType = "vegetarian",
    Allergens = new[] { "peanuts" },
    Dislikes = new[] { "mushrooms" },
    CalorieTarget = 1800
};

var bobProfile = new DietaryProfile
{
    DietType = "keto",
    Allergens = Array.Empty<string>(),
    Dislikes = new[] { "broccoli" },
    CalorieTarget = 2200
};

// Alice: personalized thread + memory
AgentThread aliceThread = mealPlanner.GetNewThread();
if (aliceThread.GetService<DietaryMemory>() is DietaryMemory aliceMemory)
{
    aliceMemory.Profile = aliceProfile;
}

// Bob: personalized thread + memory
AgentThread bobThread = mealPlanner.GetNewThread();
if (bobThread.GetService<DietaryMemory>() is DietaryMemory bobMemory)
{
    bobMemory.Profile = bobProfile;
}

Console.WriteLine(">> Alice (vegetarian, peanut allergy, dislikes mushrooms)\n");
Console.WriteLine(await mealPlanner.RunAsync("Generate a 3-day dinner plan with a short grocery list.", aliceThread));

Console.WriteLine("\n>> Bob (keto, dislikes broccoli)\n");
Console.WriteLine(await mealPlanner.RunAsync("Generate a 3-day dinner plan with a short grocery list.", bobThread));

// Optional: serialize and resume each user's thread to continue later
JsonElement aliceSaved = aliceThread.Serialize();
JsonElement bobSaved = bobThread.Serialize();

AgentThread aliceResumed = mealPlanner.DeserializeThread(aliceSaved);
AgentThread bobResumed = mealPlanner.DeserializeThread(bobSaved);

Console.WriteLine("\n>> Alice follow-up (Mediterranean style)\n");
Console.WriteLine(await mealPlanner.RunAsync("Adjust plan for Mediterranean style.", aliceResumed));

Console.WriteLine("\n>> Bob follow-up (lower carbs even more)\n");
Console.WriteLine(await mealPlanner.RunAsync("Reduce carbs further while keeping variety.", bobResumed));

// Peek stored memory for each user
var aliceResumedMemory = aliceResumed.GetService<DietaryMemory>();
var bobResumedMemory = bobResumed.GetService<DietaryMemory>();
Console.WriteLine($"\nAlice Memory -> Diet: {aliceResumedMemory?.Profile.DietType}, Allergens: {string.Join(", ", aliceResumedMemory?.Profile.Allergens ?? Array.Empty<string>())}, Dislikes: {string.Join(", ", aliceResumedMemory?.Profile.Dislikes ?? Array.Empty<string>())}, Calories: {aliceResumedMemory?.Profile.CalorieTarget}");
Console.WriteLine($"Bob Memory   -> Diet: {bobResumedMemory?.Profile.DietType}, Allergens: {string.Join(", ", bobResumedMemory?.Profile.Allergens ?? Array.Empty<string>())}, Dislikes: {string.Join(", ", bobResumedMemory?.Profile.Dislikes ?? Array.Empty<string>())}, Calories: {bobResumedMemory?.Profile.CalorieTarget}");

#!markdown

### Middleware: Add layers for safety and observability

Middleware lets you intercept and transform agent behavior at multiple levels: chat client calls, agent runs, and function invocations. This is essential for production scenarios requiring PII filtering, content guardrails, logging, or human-in-the-loop approvals.

Common use cases include security (redacting sensitive data), compliance (enforcing content policies), and observability (logging and monitoring).

#!csharp

using System.Text.RegularExpressions;

// Helper functions for the middleware example
[Description("Get the weather for a given location.")]
static string GetWeather([Description("The location to get the weather for.")] string location)
    => $"The weather in {location} is cloudy with a high of 15°C.";

[Description("The current datetime offset.")]
static string GetDateTime()
    => DateTimeOffset.Now.ToString();

// PII Filtering Middleware - Redacts phone numbers, emails, and names
async Task<AgentRunResponse> PIIMiddleware(IEnumerable<ChatMessage> messages, AgentThread? thread, AgentRunOptions? options, AIAgent innerAgent, CancellationToken cancellationToken)
{
    // Redact PII information from input messages
    var filteredMessages = FilterMessages(messages);
    Console.WriteLine(">> PII Middleware: Filtered input messages");

    var response = await innerAgent.RunAsync(filteredMessages, thread, options, cancellationToken).ConfigureAwait(false);

    // Redact PII information from output messages
    response.Messages = FilterMessages(response.Messages);
    Console.WriteLine(">> PII Middleware: Filtered output messages");

    return response;

    static IList<ChatMessage> FilterMessages(IEnumerable<ChatMessage> messages)
    {
        return messages.Select(m => new ChatMessage(m.Role, FilterPii(m.Text))).ToList();
    }

    static string FilterPii(string content)
    {
        // Regex patterns for PII detection (simplified for demonstration)
        Regex[] piiPatterns = [
            new(@"\b\d{3}-\d{3}-\d{4}\b", RegexOptions.Compiled), // Phone number (e.g., 123-456-7890)
            new(@"\b[\w\.-]+@[\w\.-]+\.\w+\b", RegexOptions.Compiled), // Email address
            new(@"\b[A-Z][a-z]+\s[A-Z][a-z]+\b", RegexOptions.Compiled) // Full name (e.g., John Doe)
        ];

        foreach (var pattern in piiPatterns)
        {
            content = pattern.Replace(content, "[REDACTED-PII]");
        }

        return content;
    }
}

// Guardrail Middleware - Blocks harmful content keywords
async Task<AgentRunResponse> GuardrailMiddleware(IEnumerable<ChatMessage> messages, AgentThread? thread, AgentRunOptions? options, AIAgent innerAgent, CancellationToken cancellationToken)
{
    // Redact keywords from input messages
    var filteredMessages = FilterMessages(messages);
    Console.WriteLine(">> Guardrail Middleware: Checked input messages");

    var response = await innerAgent.RunAsync(filteredMessages, thread, options, cancellationToken);

    // Redact keywords from output messages
    response.Messages = FilterMessages(response.Messages);
    Console.WriteLine(">> Guardrail Middleware: Checked output messages");

    return response;

    List<ChatMessage> FilterMessages(IEnumerable<ChatMessage> messages)
    {
        return messages.Select(m => new ChatMessage(m.Role, FilterContent(m.Text))).ToList();
    }

    static string FilterContent(string content)
    {
        foreach (var keyword in new[] { "harmful", "illegal", "violence" })
        {
            if (content.Contains(keyword, StringComparison.OrdinalIgnoreCase))
            {
                return "[REDACTED: Forbidden content detected]";
            }
        }
        return content;
    }
}

// Function Call Logging Middleware
async ValueTask<object?> FunctionCallLoggingMiddleware(AIAgent agent, FunctionInvocationContext context, Func<FunctionInvocationContext, CancellationToken, ValueTask<object?>> next, CancellationToken cancellationToken)
{
    Console.WriteLine($">> Function Middleware: Calling {context.Function.Name}");
    var result = await next(context, cancellationToken);
    Console.WriteLine($">> Function Middleware: {context.Function.Name} completed");
    return result;
}

// Function Result Override Middleware - Overrides weather results
async ValueTask<object?> FunctionOverrideWeatherMiddleware(AIAgent agent, FunctionInvocationContext context, Func<FunctionInvocationContext, CancellationToken, ValueTask<object?>> next, CancellationToken cancellationToken)
{
    var result = await next(context, cancellationToken);
    
    if (context.Function.Name == nameof(GetWeather))
    {
        Console.WriteLine($">> Override Middleware: Changing weather result");
        result = "The weather is sunny with a high of 25°C.";
    }
    return result;
}

// Build agent with multiple middleware layers
var middlewareAgent = chatClient.CreateAIAgent(
    instructions: "You are a helpful assistant that provides information.",
    name: "MiddlewareAgent",
    tools: [AIFunctionFactory.Create(GetDateTime), AIFunctionFactory.Create(GetWeather)])
    .AsBuilder()
    .Use(FunctionCallLoggingMiddleware)
    .Use(FunctionOverrideWeatherMiddleware)
    .Use(PIIMiddleware, null)
    .Use(GuardrailMiddleware, null)
    .Build();

Console.WriteLine("\n=== Example 1: Guardrail blocks harmful content ===");
var guardResponse = await middlewareAgent.RunAsync("Tell me something harmful.");
Console.WriteLine($"Response: {guardResponse}\n");

Console.WriteLine("\n=== Example 2: PII filtering in action ===");
var piiResponse = await middlewareAgent.RunAsync("My name is John Doe, call me at 123-456-7890 or email john@example.com");
Console.WriteLine($"Response: {piiResponse}\n");

Console.WriteLine("\n=== Example 3: Function middleware with override ===");
var functionResponse = await middlewareAgent.RunAsync("What's the time and the weather in Seattle?");
Console.WriteLine($"Response: {functionResponse}");

#!markdown

## Customer Support Agent with Plugins

Real-world customer support scenario using dependency injection. This example demonstrates:

- **CRM integration**: Looking up customer information and order history
- **Inventory system**: Checking product availability and stock levels
- **Plugin architecture**: Using `ServiceCollection` for dependency injection
- **Business logic separation**: Service classes with constructor and parameter injection
- **Explicit function exposure**: Controlling which methods are available as AI tools

#!csharp

using Microsoft.Extensions.DependencyInjection;

// Simulate a CRM system with customer data
public class CustomerService
{
    private readonly Dictionary<string, CustomerRecord> _customers = new()
    {
        ["CUST-001"] = new CustomerRecord 
        { 
            CustomerId = "CUST-001", 
            Name = "Alice Johnson", 
            Email = "alice.johnson@example.com",
            MembershipTier = "Gold",
            AccountBalance = 1250.00m
        },
        ["CUST-002"] = new CustomerRecord 
        { 
            CustomerId = "CUST-002", 
            Name = "Bob Smith", 
            Email = "bob.smith@example.com",
            MembershipTier = "Silver",
            AccountBalance = -45.00m
        }
    };

    public CustomerRecord? GetCustomer(string customerId)
    {
        _customers.TryGetValue(customerId, out var customer);
        return customer;
    }

    public string GetCustomerSummary(string customerId)
    {
        var customer = GetCustomer(customerId);
        if (customer == null)
            return $"Customer {customerId} not found.";

        return $"Customer: {customer.Name}\n" +
               $"Email: {customer.Email}\n" +
               $"Membership: {customer.MembershipTier}\n" +
               $"Account Balance: ${customer.AccountBalance:F2}";
    }
}

public record CustomerRecord
{
    public string CustomerId { get; init; } = "";
    public string Name { get; init; } = "";
    public string Email { get; init; } = "";
    public string MembershipTier { get; init; } = "";
    public decimal AccountBalance { get; init; }
}

// Simulate an order management system
public class OrderService
{
    private readonly Dictionary<string, List<OrderRecord>> _ordersByCustomer = new()
    {
        ["CUST-001"] = new List<OrderRecord>
        {
            new() { OrderId = "ORD-1001", ProductName = "Laptop Pro 15", Quantity = 1, Price = 1299.99m, Status = "Delivered", OrderDate = DateTime.Now.AddDays(-10) },
            new() { OrderId = "ORD-1005", ProductName = "Wireless Mouse", Quantity = 2, Price = 29.99m, Status = "Shipped", OrderDate = DateTime.Now.AddDays(-2) }
        },
        ["CUST-002"] = new List<OrderRecord>
        {
            new() { OrderId = "ORD-1003", ProductName = "USB-C Cable", Quantity = 3, Price = 15.99m, Status = "Processing", OrderDate = DateTime.Now.AddDays(-1) }
        }
    };

    public string GetRecentOrders(string customerId, int count = 5)
    {
        if (!_ordersByCustomer.TryGetValue(customerId, out var orders))
            return $"No orders found for customer {customerId}.";

        var recentOrders = orders.OrderByDescending(o => o.OrderDate).Take(count);
        var summary = $"Recent orders for {customerId}:\n\n";
        
        foreach (var order in recentOrders)
        {
            summary += $"Order #{order.OrderId} - {order.ProductName}\n" +
                      $"  Quantity: {order.Quantity}, Price: ${order.Price:F2}\n" +
                      $"  Status: {order.Status}, Date: {order.OrderDate:MM/dd/yyyy}\n\n";
        }
        
        return summary;
    }
}

public record OrderRecord
{
    public string OrderId { get; init; } = "";
    public string ProductName { get; init; } = "";
    public int Quantity { get; init; }
    public decimal Price { get; init; }
    public string Status { get; init; } = "";
    public DateTime OrderDate { get; init; }
}

// Simulate an inventory system
public class InventoryService
{
    private readonly Dictionary<string, InventoryItem> _inventory = new()
    {
        ["LAPTOP-PRO"] = new InventoryItem { Sku = "LAPTOP-PRO", Name = "Laptop Pro 15", InStock = 45, ReorderPoint = 10 },
        ["MOUSE-WL"] = new InventoryItem { Sku = "MOUSE-WL", Name = "Wireless Mouse", InStock = 3, ReorderPoint = 20 },
        ["CABLE-USBC"] = new InventoryItem { Sku = "CABLE-USBC", Name = "USB-C Cable", InStock = 150, ReorderPoint = 50 }
    };

    public string CheckStock(string productSku)
    {
        if (!_inventory.TryGetValue(productSku, out var item))
            return $"Product {productSku} not found in inventory.";

        var status = item.InStock > item.ReorderPoint ? "In Stock" : 
                     item.InStock > 0 ? "Low Stock - Reorder Needed" : 
                     "Out of Stock";

        return $"Product: {item.Name} (SKU: {item.Sku})\n" +
               $"Available: {item.InStock} units\n" +
               $"Status: {status}";
    }
}

public record InventoryItem
{
    public string Sku { get; init; } = "";
    public string Name { get; init; } = "";
    public int InStock { get; init; }
    public int ReorderPoint { get; init; }
}

// Customer support plugin that integrates all services
public class CustomerSupportPlugin
{
    private readonly CustomerService _customerService;
    
    // Constructor injection
    public CustomerSupportPlugin(CustomerService customerService)
    {
        _customerService = customerService;
    }
    
    // Uses constructor-injected dependency
    public string GetCustomerInfo(string customerId)
    {
        return _customerService.GetCustomerSummary(customerId);
    }
    
    // Uses IServiceProvider parameter injection for on-demand service resolution
    public string GetOrderHistory(IServiceProvider sp, string customerId)
    {
        var orderService = sp.GetRequiredService<OrderService>();
        return orderService.GetRecentOrders(customerId);
    }
    
    // Uses IServiceProvider parameter injection
    public string CheckInventory(IServiceProvider sp, string productSku)
    {
        var inventoryService = sp.GetRequiredService<InventoryService>();
        return inventoryService.CheckStock(productSku);
    }
    
    // Explicitly expose methods as AI tools (returns AITool not AIFunction)
    public IEnumerable<AITool> AsAITools()
    {
        yield return AIFunctionFactory.Create(
            (string customerId) => GetCustomerInfo(customerId),
            name: "GetCustomerInfo",
            description: "Retrieves customer profile information including name, email, membership tier, and account balance");
            
        yield return AIFunctionFactory.Create(
            (IServiceProvider sp, string customerId) => GetOrderHistory(sp, customerId),
            name: "GetOrderHistory",
            description: "Retrieves recent order history for a customer including order status and details");
            
        yield return AIFunctionFactory.Create(
            (IServiceProvider sp, string productSku) => CheckInventory(sp, productSku),
            name: "CheckInventory",
            description: "Checks current inventory levels and stock status for a product SKU");
    }
}

// Setup dependency injection container
var supportServices = new ServiceCollection();
supportServices.AddSingleton<CustomerService>();
supportServices.AddSingleton<OrderService>();
supportServices.AddSingleton<InventoryService>();
supportServices.AddSingleton<CustomerSupportPlugin>();
var supportServiceProvider = supportServices.BuildServiceProvider();

// Get the plugin and its tools
var supportPlugin = supportServiceProvider.GetRequiredService<CustomerSupportPlugin>();
var supportTools = supportPlugin.AsAITools().ToArray();

// Create customer support agent with plugin tools
var supportAgent = chatClient.AsIChatClient().CreateAIAgent(
    instructions: "You are a helpful customer support agent. Use the available tools to look up customer information, order history, and inventory status. Be professional, empathetic, and provide accurate information.",
    name: "SupportAgent",
    tools: supportTools,  // Pass tools array here
    services: supportServiceProvider  // Pass service provider (lowercase 'services')
);

var supportThread = supportAgent.GetNewThread();

// Test the customer support agent with realistic scenarios
Console.WriteLine("=== Scenario 1: Customer Inquiry ===\n");
var inquiry1 = await supportAgent.RunAsync(
    "Hi, I'm customer CUST-001. Can you tell me about my recent orders and account status?", 
    supportThread);
Console.WriteLine(inquiry1);

Console.WriteLine("\n\n=== Scenario 2: Stock Check ===\n");
var inquiry2 = await supportAgent.RunAsync(
    "I want to order a wireless mouse (SKU: MOUSE-WL). Is it in stock?", 
    supportThread);
Console.WriteLine(inquiry2);

#!markdown

# Document Review Agent with Chat History Reduction

Real-world document analysis scenario with context window management. This example demonstrates:

- **Long document processing**: Handling multiple document sections
- **Chat history limits**: Keeping conversations within model context limits
- **Context pruning**: Automatically removing old context when limit is exceeded
- **Memory vs. context tradeoff**: Understanding what information is preserved vs. lost
- **Business impact**: How context limits affect agent's ability to reference earlier content

#!csharp

using System.Threading;

#pragma warning disable 
// Custom chat reducer that keeps only the last N non-system messages
public class MessageCountingChatReducer : IChatReducer
{
    private readonly int _maxMessages;

    public MessageCountingChatReducer(int maxMessages)
    {
        _maxMessages = maxMessages;
    }

    public Task<IEnumerable<ChatMessage>> ReduceAsync(
        IEnumerable<ChatMessage> messages, 
        CancellationToken cancellationToken = default)
    {
        var messageList = messages.ToList();
        
        // Separate system messages from other messages
        var systemMessages = messageList.Where(m => m.Role == ChatRole.System).ToList();
        var nonSystemMessages = messageList.Where(m => m.Role != ChatRole.System).ToList();
        
        // Keep only the last N non-system messages
        var reducedNonSystemMessages = nonSystemMessages.TakeLast(_maxMessages).ToList();
        
        // Combine system messages with reduced non-system messages
        var result = systemMessages.Concat(reducedNonSystemMessages);
        
        return Task.FromResult(result);
    }
}

// Simulate document sections for a contract review
string contractSection1 = @"
SECTION 1 - PAYMENT TERMS:
- Total contract value: $500,000
- Payment schedule: Quarterly installments
- Due dates: March 31, June 30, September 30, December 31
- Late payment penalty: 1.5% per month
";

string contractSection2 = @"
SECTION 2 - DELIVERABLES:
- Phase 1: Requirements Analysis (30 days)
- Phase 2: System Design (45 days)
- Phase 3: Implementation (90 days)
- Phase 4: Testing and Deployment (30 days)
- Total project duration: 195 days
";

string contractSection3 = @"
SECTION 3 - WARRANTY AND SUPPORT:
- Warranty period: 12 months from deployment
- Support hours: 24/7 for critical issues
- Response time: 2 hours for critical, 8 hours for standard
- Support team size: Minimum 3 dedicated engineers
";

string contractSection4 = @"
SECTION 4 - TERMINATION CLAUSES:
- Either party may terminate with 60 days written notice
- Termination fees: 25% of remaining contract value
- Intellectual property rights revert to client upon termination
- All work products delivered within 15 days of termination
";

// Create a document review agent with limited chat history (keeps only last 4 messages)
var documentReviewAgent = chatClient.AsIChatClient().CreateAIAgent(new ChatClientAgentOptions
{
    Instructions = @"You are a legal document review assistant. Analyze contract sections, identify key terms, 
                     risks, and provide recommendations. Be thorough and reference specific clause details.",
    Name = "DocumentReviewer",
    // Limit to last 4 non-system messages to simulate context window constraints
    ChatMessageStoreFactory = ctx => new InMemoryChatMessageStore(
        new MessageCountingChatReducer(4), 
        ctx.SerializedState, 
        ctx.JsonSerializerOptions)
});

var reviewThread = documentReviewAgent.GetNewThread();
var reviewChatHistory = reviewThread.GetService<IList<ChatMessage>>();

// Review multiple sections - watching context window fill up
Console.WriteLine("=== Reviewing Section 1: Payment Terms ===");
var review1 = await documentReviewAgent.RunAsync(
    $"Please review this contract section and identify key payment terms:\n{contractSection1}", 
    reviewThread);
Console.WriteLine(review1);
Console.WriteLine($"\n📊 Chat history: {reviewChatHistory?.Count} messages\n");

Console.WriteLine("\n=== Reviewing Section 2: Deliverables ===");
var review2 = await documentReviewAgent.RunAsync(
    $"Now review this deliverables section:\n{contractSection2}", 
    reviewThread);
Console.WriteLine(review2);
Console.WriteLine($"\n📊 Chat history: {reviewChatHistory?.Count} messages\n");

Console.WriteLine("\n=== Reviewing Section 3: Warranty ===");
var review3 = await documentReviewAgent.RunAsync(
    $"Review the warranty and support terms:\n{contractSection3}", 
    reviewThread);
Console.WriteLine(review3);
Console.WriteLine($"\n📊 Chat history: {reviewChatHistory?.Count} messages\n");

Console.WriteLine("\n=== Reviewing Section 4: Termination ===");
var review4 = await documentReviewAgent.RunAsync(
    $"Review the termination clauses:\n{contractSection4}", 
    reviewThread);
Console.WriteLine(review4);
Console.WriteLine($"\n📊 Chat history: {reviewChatHistory?.Count} messages\n");

// At this point, the context window is full. Section 1 (Payment Terms) has been removed from history.
// The agent can no longer reference the payment terms we reviewed first.

Console.WriteLine("\n=== ⚠️ CONTEXT LIMIT EXCEEDED - Testing Lost Context ===");
var followUp = await documentReviewAgent.RunAsync(
    @"Based on your review, what's the total contract value and how does it relate to the termination fees? 
      Please provide the calculation.", 
    reviewThread);
Console.WriteLine(followUp);
Console.WriteLine($"\n📊 Final chat history: {reviewChatHistory?.Count} messages");

Console.WriteLine("\n⚠️ IMPORTANT BUSINESS IMPACT:");
Console.WriteLine("The agent cannot accurately answer because Section 1 (Payment Terms) was removed from context.");
Console.WriteLine("This demonstrates why chat history reduction must be carefully considered in production systems.");
Console.WriteLine("\nSOLUTIONS for production:");
Console.WriteLine("• Increase context window size based on business needs");
Console.WriteLine("• Implement summarization instead of simple truncation");
Console.WriteLine("• Store critical information in persistent memory/database");
Console.WriteLine("• Use RAG (Retrieval Augmented Generation) for document analysis");
